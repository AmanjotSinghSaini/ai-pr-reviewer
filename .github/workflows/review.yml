name: 'AI Code Reviewer'

on:
  workflow_call:
    inputs:
      enable_gitleaks:
        description: 'Enable Gitleaks secrets scanning'
        required: false
        type: boolean
        default: true
      ai_model:
        description: 'AI model to use for code review'
        required: false
        type: string
        default: 'gpt-4o-mini'
      exclude_paths:
        description: 'Comma-separated paths to exclude from AI review'
        required: false
        type: string
        default: '*.md,*.txt,*.json,package-lock.json,yarn.lock'

jobs:
  ai-code-review:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    permissions:
      contents: read
      pull-requests: write
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Get changed files
        id: changed-files
        run: |
          echo "Getting changed files between base and head..."
          
          # Get list of changed files
          git diff --name-only ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} > changed_files.txt
          
          echo "Changed files:"
          cat changed_files.txt
          
          # Filter out excluded paths
          IFS=',' read -ra EXCLUDE_ARRAY <<< "${{ inputs.exclude_paths }}"
          
          filtered_files=""
          while IFS= read -r file; do
            if [[ -z "$file" ]]; then continue; fi
            
            exclude_file=false
            for pattern in "${EXCLUDE_ARRAY[@]}"; do
              pattern=$(echo "$pattern" | xargs) # trim whitespace
              if [[ "$file" == $pattern ]] || [[ "$file" == *"$pattern"* ]]; then
                exclude_file=true
                break
              fi
            done
            
            if [[ "$exclude_file" == false && -f "$file" ]]; then
              filtered_files="$filtered_files$file"$'\n'
            fi
          done < changed_files.txt
          
          echo -n "$filtered_files" > filtered_changed_files.txt
          
          echo "Filtered files for review:"
          cat filtered_changed_files.txt
          
          if [[ -s filtered_changed_files.txt ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Run Gitleaks Security Scan
        if: inputs.enable_gitleaks == true
        id: gitleaks
        run: |
          echo "Running Gitleaks security scan..."
          
          gitleaks_output=""
          secrets_found=false
          
          if [[ -s filtered_changed_files.txt ]]; then
            while IFS= read -r file; do
              if [[ -n "$file" && -f "$file" ]]; then
                echo "Scanning file: $file"
                
                # Run gitleaks on individual file using docker
                result=$(docker run --rm -v "${PWD}:/workspace" zricethezav/gitleaks:latest detect \
                  --source "/workspace/$file" \
                  --no-git \
                  --verbose \
                  --exit-code 1 2>&1 || true)
                
                # Check if secrets were found
                if echo "$result" | grep -q -E "(Finding:|Secret|detected|found)" && ! echo "$result" | grep -q "no leaks found"; then
                  secrets_found=true
                  gitleaks_output="$gitleaks_output\n### 🚨 Security Alert - Potential secrets in: \`$file\`\n\`\`\`\n$result\n\`\`\`\n"
                fi
              fi
            done < filtered_changed_files.txt
          fi
          
          if [[ "$secrets_found" == true ]]; then
            echo "secrets_found=true" >> $GITHUB_OUTPUT
            echo -e "$gitleaks_output" > gitleaks_results.txt
          else
            echo "secrets_found=false" >> $GITHUB_OUTPUT
            echo "✅ No secrets detected in changed files." > gitleaks_results.txt
          fi

      - name: Prepare code for AI review
        if: steps.changed-files.outputs.has_changes == 'true'
        id: prepare-code
        run: |
          echo "Preparing code for AI review..."
          
          review_content=""
          file_count=0
          total_lines=0
          
          while IFS= read -r file; do
            if [[ -n "$file" && -f "$file" && -s "$file" ]]; then
              file_size=$(wc -l < "$file" 2>/dev/null || echo "0")
              
              echo "Processing file: $file ($file_size lines)"
              
              # Skip very large files to avoid token limits
              if [[ $file_size -gt 500 ]]; then
                review_content="$review_content\n\n### 📄 File: \`$file\` ($file_size lines - showing first 100 lines)\n\`\`\`\n$(head -n 100 "$file")\n... [File truncated for review] ...\n\`\`\`"
              else
                file_extension="${file##*.}"
                review_content="$review_content\n\n### 📄 File: \`$file\` ($file_size lines)\n\`\`\`$file_extension\n$(cat "$file")\n\`\`\`"
              fi
              
              file_count=$((file_count + 1))
              total_lines=$((total_lines + file_size))
              
              # Prevent overwhelming the AI with too much content
              if [[ $file_count -ge 15 || $total_lines -ge 3000 ]]; then
                review_content="$review_content\n\n*Note: Review limited to first $file_count files ($total_lines lines total) to stay within API limits.*"
                break
              fi
            fi
          done < filtered_changed_files.txt
          
          echo -e "$review_content" > code_for_review.txt
          
          echo "file_count=$file_count" >> $GITHUB_OUTPUT
          echo "total_lines=$total_lines" >> $GITHUB_OUTPUT
          
          echo "Prepared $file_count files ($total_lines lines) for review"

      - name: AI Code Review
        if: steps.changed-files.outputs.has_changes == 'true'
        id: ai-review
        run: |
          echo "Starting AI code review..."
          
          # Create the review prompt
          cat << 'EOF' > review_prompt.txt
          You are an expert code reviewer. Please analyze the following code changes in a pull request and provide constructive feedback.

          **Focus Areas:**
          1. **Security Issues**: Vulnerabilities, injection risks, unsafe practices
          2. **Code Quality**: Logic errors, potential bugs, error handling  
          3. **Performance**: Inefficient algorithms, resource usage issues
          4. **Best Practices**: Coding standards, design patterns, maintainability
          5. **Documentation**: Missing comments, unclear naming

          **Response Format:**
          Please structure your response exactly like this:

          ## 🤖 AI Code Review

          ### ✅ What's Working Well
          - [List positive aspects of the code]

          ### ⚠️ Issues Found  
          - **[HIGH/MEDIUM/LOW]**: [Issue description]
            - *Suggestion*: [How to fix it]
            - *Example*: [Code example if helpful]

          ### 💡 Recommendations
          - [General improvement suggestions]

          **Be specific, constructive, and focus on actionable feedback. If code looks good, mention that too.**

          ---

          **Code Changes to Review:**
          EOF
          
          # Append the code content
          cat code_for_review.txt >> review_prompt.txt
          
          # Call GitHub Models API
          echo "Making API request to GitHub Models..."
          
          response=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Content-Type: application/json" \
            -H "User-Agent: GitHubActions/1.0" \
            -d "$(jq -n \
              --arg model "${{ inputs.ai_model }}" \
              --arg content "$(cat review_prompt.txt)" \
              '{
                "model": $model,
                "messages": [
                  {
                    "role": "user", 
                    "content": $content
                  }
                ],
                "max_tokens": 2000,
                "temperature": 0.3
              }')" \
            "https://models.inference.ai.azure.com/chat/completions")
          
          # Split response and status code
          http_code=$(echo "$response" | tail -n1)
          response_body=$(echo "$response" | head -n -1)
          
          echo "HTTP Status Code: $http_code"
          
          if [[ "$http_code" == "200" ]]; then
            # Extract AI response
            ai_feedback=$(echo "$response_body" | jq -r '.choices[0].message.content // empty')
            
            if [[ -n "$ai_feedback" && "$ai_feedback" != "null" ]]; then
              echo "$ai_feedback" > ai_review_results.txt
              echo "review_completed=true" >> $GITHUB_OUTPUT
              echo "AI review completed successfully"
            else
              echo "## 🤖 AI Code Review\n\n⚠️ AI review completed but no content was returned. Please review the changes manually." > ai_review_results.txt
              echo "review_completed=partial" >> $GITHUB_OUTPUT
            fi
          else
            echo "API Error - Status: $http_code"
            echo "$response_body"
            echo "## 🤖 AI Code Review\n\n⚠️ AI review service is temporarily unavailable (HTTP $http_code). Please review the code changes manually.\n\nThe changes are ready for human review." > ai_review_results.txt
            echo "review_completed=false" >> $GITHUB_OUTPUT
          fi

      - name: Post Review Comment
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            let comment = '# 🤖 Automated Code Review Report\n\n';
            comment += `*Generated on: ${new Date().toLocaleString('en-US', {timeZone: 'UTC'})} UTC*\n\n`;
            
            // Add security scan results
            if (${{ inputs.enable_gitleaks }}) {
              comment += '## 🔐 Security Scan Results\n\n';
              try {
                const gitleaksResults = fs.readFileSync('gitleaks_results.txt', 'utf8');
                comment += gitleaksResults + '\n\n';
              } catch (error) {
                comment += '⚠️ Security scan could not be completed.\n\n';
              }
            }
            
            // Add AI review results
            if ('${{ steps.changed-files.outputs.has_changes }}' === 'true') {
              try {
                const aiResults = fs.readFileSync('ai_review_results.txt', 'utf8');
                comment += aiResults + '\n\n';
              } catch (error) {
                comment += '## 🤖 AI Code Review\n\n⚠️ AI code review could not be completed.\n\n';
              }
              
              comment += '---\n\n';
              comment += `📊 **Review Statistics**\n`;
              comment += `- **Files Reviewed**: ${{ steps.prepare-code.outputs.file_count || 0 }}\n`;
              comment += `- **Lines of Code**: ${{ steps.prepare-code.outputs.total_lines || 0 }}\n`;
              comment += `- **AI Model Used**: ${{ inputs.ai_model }}\n`;
              comment += `- **Security Scan**: ${{ inputs.enable_gitleaks && 'Enabled' || 'Disabled' }}\n\n`;
            } else {
              comment += '## 📝 Code Review Status\n\n';
              comment += 'ℹ️ No reviewable code changes detected in this pull request.\n\n';
            }
            
            comment += '---\n';
            comment += '*This is an automated review. Human oversight is recommended for production deployments.*';
            
            // Post the comment
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              console.log('Review comment posted successfully');
            } catch (error) {
              console.error('Failed to post comment:', error);
              core.setFailed(`Failed to post review comment: ${error.message}`);
            }

      - name: Cleanup temporary files
        if: always()
        run: |
          echo "Cleaning up temporary files..."
          rm -f changed_files.txt filtered_changed_files.txt code_for_review.txt
          rm -f review_prompt.txt ai_review_results.txt gitleaks_results.txt
          echo "Cleanup completed"
